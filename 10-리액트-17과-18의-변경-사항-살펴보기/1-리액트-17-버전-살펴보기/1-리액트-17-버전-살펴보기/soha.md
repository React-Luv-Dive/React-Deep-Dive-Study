## 10.1 리액트 17 버전 살펴보기

리액트 17버전은 16버전에서 새롭게 추가된 기능은 없다.
호호나성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다.  
이는 10만개 이상의 컴포넌트 중 호호나성이 깨지는 변경 사항은 20개 미만이다.  
따라서, 16 버전에서 17 버전으로의 버전 업은 큰 부담 없이 할 수 있다.

### 10.1.1 리액트의 점진적인 업그레이드

기존의 리액트는 **유의적 버전을 기반으로 업데이트**를 거치고 있었다.  
새로운 주 버전이 릴리스되면 이전 버전에서의 API 제공을 완전히 중단하고, 전체 애플리케이션을 새롭게 업그레이드 하기를 요구했다.  
이런 업그레이드는 리액트 개발자 입장에서는 편리하지만, 리액트를 사용하는 개발자 입장에서는 매우 번거롭다. 새로운 버전으로 업그레이드 되면서 어떠한 API의 수정이 있는지 일일이 확인해서 적용하는 등을 해야 한다.

> **주 버전**  
> 16 -> 17 / 새로운 기능, 구조 변경, 성능 개선 등 호환되지 않는 변경 사항이 도입
>
> **수 버전**  
> 16.7 -> 16.8 / 신규 기능 추가, 성능 향상, 기존 기능의 변경 없이 호환성을 유지

그러나, 리액트 17부터는 **점진적 업그레이드**가 가능해진다.
리액트 17을 설치하고, 이후에 리액트 18로 업데이트를 하게 된다면 리액트 18에서 제공하는 대부분의 기능을 사용할 수 있으면서 일부 기능에 대해서는 리액트 17에 머물러 있을 수 있다.  
즉, 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능하다.  
물론 이러한 방법이 관리 지점이 많아지나, 리액트 버전을 올리기에 부담되는 큰 애플리케이션의 경우에는 충분히 고려해볼 만한 선택지이다.

### 10.1.2 이벤트 위임 방식의 변경

리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입 (click, change)당 하나의 핸들러를 루트에 부착한다. 이를 이벤트 위임이라 한다.

> **이벤트 구성 단계**
>
> 1. 캡쳐(capture): 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것
> 2. 타깃 (target): 이벤트 핸들러가 타깃 노드에 도달하는 단계로, 이벤트가 호출
> 3. 버블링(bubbling): 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라감

이벤트 위임이란 이러한 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다. (만약 모든 li 요소에 이벤트가 필요하다면 li에 이벤트를 다 추가하는 것이 아닌, ul에만 이벤트를 추가하여 li에 이벤트를 위임하는 것)

이러한 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행됐다.  
그러나, 리액트 17부터 이런 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트의 최상단 트리, 즉 루트 요소로 변경됐다.

이에 대한 이유는 점진적인 업그레이드 지원, 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위해서 이다.  
만약, 점진적인 업그레이드 지원이 활성화 되어 있는데 모든 이벤트가 document에 달려 있다면, document의 이벤트 전파를 막을 수 없다.  
이처럼 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해서 이벤트 위임의 대상을 document에서 컴포넌트의 최상위로 변경했다.  
이렇게 되면 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되어 이벤트 버블링으로 인한 혼선을 방지할 수 있다.

### 10.1.3 import React from 'react'가 더 이상 필요 없다: 새로운 JSX transform

JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요하다.  
(대부분의 경우에는 이런 변환 작업이 개발자에게 보여지지 않는다. 특히 CRA를 사용했으면 이런 처리 경험이 없을 것이다.)

16 버전까지는 이런 JSX 변환을 사용하기 위해서 코드 내에서 React를 사용하는 구문이 없더라도 `import React from 'react'`가 필요했다. 해당 코드가 없으면 에러가 발생했다.

그러나 리액트 17 버전부터 바벨과 협력하여 이런 import 구문 없이도 JSX를 변환할 수 있게 했다.  
이에 대한 장점으로 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄이고 컴포넌트 작성을 더욱 간결하게 만든다는 것이 있다.

### 10.1.4 그 밖의 주요 변경 사항

#### 이벤트 풀링 제거

**이벤트 풀링?**  
SyntheticEvent 풀을 만들어서 이벤트가 발생할 때 마다 가져오는 것이다.

> **SyntheticEvent?**  
> 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체이다.
> 해당 이벤트는 메모리 누수를 방지하기 위해 만들어졌다.

**이벤트 풀링 원리**

1. 이벤트 핸들러가 이벤트 발생시킴
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져옴
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어줌
4. 유저가 지정한 이벤트 리스너가 실행
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아옴

그러나 이런 이벤트 풀링은 비동기 코드로 이벤트 핸들러에 접근했을 때, 에러가 발생한다. 에러를 해결하기 위해서는 `e.persist()`같은 처리가 필요한데, 해당 방식은 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다. 또한, 모던 브라우저에서 이런 방식이 성능 향상에 크게 도움되지 않는다.
그리고 이런 이벤트 처리에 대한 성능이 모던 브라우저에서 많이 개선됐기 때문에 이벤트 풀링 개념이 삭제되었다.

따라서, 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 코딩할 수 있게 됐다.

#### useEffect 클린업 함수의 비동기 실행

리액트 16 버전까지는 useEffect에 있는 클린업 함수는 동기적으로 처리됐다. 따라서 클린업 함수가 완료되기 전까지는 다른 작업을 방해하므로 불필요한 성능 저하가 발생했다.

그러나 리액트 17 버전부터 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행되도록 변경됐다.  
컴포넌트의 커밋 단계가 완료될 때까지 지연된다. 즉, 화면이 업데이트가 완전히 끝난 이후에 실행되도록 변경됐다.

> **클린업 함수?**  
> 이펙트가 호출되기 전과 컴포넌트가 언마운트될 때, 호출되면서 이전 이펙트로 인한 결과를 정리

#### 컴포넌트의 undefined 반환에 대한 일관적인 처리

리액트 16과 17 버전은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생한다. 이는 의도치 않게 잘못된 반환으로 인한 실수를 방자히가 위해서였다.

그러나, 리액트 16에서 forwardRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러가 발생하지 않는 문제가 존재했다.

리액트 17부터 에러가 정상적으로 발생하도록 변경됐다.  
추가로 리액트 18부터는 undefined를 반환해도 에러가 발생하지 않는다.

### 10.1.5 정리

리액트 17 버전은 사용자에게 영향을 미칠 수 있는 큰 변화를 최소화하고 다음 버전 업을 위한 버전 업 정도이다.
