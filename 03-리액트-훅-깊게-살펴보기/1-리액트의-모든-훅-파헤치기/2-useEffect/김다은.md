> 애플리케이션 내 컴포넌트의 여러 값들을 활용해 부수효과를 만드는 메커니즘

### useEffect은 어떻게 변화를 감지할까?

- 함수형 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다.
- useEffect은 그저 렌더링할 때마다 의존성이 있는 변수를 보면서 의존성 값이 하나라도 다른게 있다면 부수 효과를 실행하는 평범한 함수다. 옵저버나 proxy같은 복잡한 패턴을 쓰는 게 전혀 아니다.

### 클린업 함수

- useEffect의 첫 번째 인자로 전달되는 콜백함수의 return으로 또 다른 콜백 함수를 전달할 수 있다. 이는 새로운 값 뒤에 렌더링이 일어난 후 실행되지만, 콜백함수 안에서 참조하는 state 값은 업데이트 하기 전의 값이 나온다. 그 이유는 클린업 함수는 **다음 렌더링 이후**에 실행되기 때문이다. 클린업 함수에서 state를 참조해도 선언됐을 당시의 값을 기억하기 때문에 업데이트 하기 전의 값이 나온다.
- 때문에 useEffect에서 이벤트 리스너를 등록해주면 반드시 클린업 함수에서 이벤트 리스너를 제거해줘야 한다. 그래야 같은 이벤트 리스너가 여러 개 부착되는 걸 방지할 수 있다.
- 따라서 클린업 함수는 **언마운트를 감지하는 생명주기 함수와는 의미가 다르다**. 말 그대로 이전 상태를 청소해 주는 개념으로 보는 게 옳다.

### 의존성 배열이 없는 경우

- 의존성 배열이 전달되지 않는 경우 useEffect은 매 렌더링마다 실행된다. 그러면 useEffect을 쓰는 이유가 없지 않나? 하는 의문이 든다. 하지만 다음과 같은 차이가 있다.
  - useEffect은 렌더링 관점에서 클라이언트 사이드에서 실행됨을 보장한다.
  - useEffect은 렌더링이 완료된 후에 실행된다. 따라서 부수효과로 인해 컴포넌트의 렌더링이 방해받는 일을 방지한다.

### 의존성 배열에 빈 배열이 전달된 경우

- 이는 주로 클래스형 컴포넌트의 `componentDidMount`와 같은 효과를 내기 위해서 사용한다. 하지만 이건 가급적 사용하면 안된다.
- 빈 배열을 전달한다는 것은 **useEffect이 실제로 관찰해서 실행되어야 하는 값과는 별개로 작동한다는 것을 의미한다.**
- 따라서 정말로 빈 배열을 전달하는 게 필요하다면 `정말로 컴포넌트가 마운트된 최초에만 실행되어야 하는 건지` 다시 생각해봐야 한다. 만약 정말 그렇다면, `콜백 함수의 실행 위치가 잘못됐을 수 있다`.
  - useEffect의 부수 효과가 컴포넌트 상태와 별개로 작동되어야 하는지?
  - 여기서 호출하는 게 최선일지?
