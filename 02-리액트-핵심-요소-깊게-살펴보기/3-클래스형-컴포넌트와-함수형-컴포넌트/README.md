## 2.3 클래스 컴포넌트와 함수 컴포넌트

### 2.3.1 클래스 컴포넌트

```jsx
import React from 'react';

class SampleComponent extends React.Component {
	render() {
		return <h2>Sample Component</h2>;
	}
}
```

클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends 해야 한다.

- extends 구문에 넣을 수 있는 클래스
  - React.component
  - React.PureComponent

#### 클래스 컴포넌트의 생명주기 메서드

- 생명주기 메서드가 실행되는 시점

  - 마운트 (mount): 컴포넌트가 마운팅(생성)되는 시점
  - 업데이트 (update): 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
  - 언마운트(unmount): 컴포넌트가 더 이상 존재하지 않는 시점

- **render()**

  리액트 컴포넌트의 유일한 필수값으로 항상 쓰인다.  
  컴포넌트가 UI를 렌더링하기 위해서 쓰인다.  
  마운트와 업데이트 과정에서 일어난다.

  항상 순수해야 하며 부수 효과가 없어야 한다.(no side-effects)  
  즉, 같은 입력값이 들어가면 항상 같은 결과물을 반환해야 한다.  
  따라서, state를 직접 업데이트하는 `this.setState`를 호출해서는 안된다.

- **componentDidMount()**

  컴포넌트가 마운트되고 준비되는 즉시 실행된다.  
  render()와 다르게 state 값을 변경하는 것이 가능하다.  
  브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.  
  _그러나, 일반적으로 state를 다루는 것은 생성자에서 하는 것이 좋다._

- **componentsDidUpdate()**

  컴포넌트 업데이트가 일어난 이후 바로 실행된다.  
  state나 props의 변화에 따라 DOM을 업데이트하는 등에 쓰인다.  
  state 값을 변경할 수는 있지만 적절한 조건문으로 감싸지 않는다면 `this.setState`가 계속해서 호출되는 일이 발생할 수 있다.

- **componentWillUnmount()**

  컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.  
  메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치다.  
  그러나, `this.setState`를 호출할 수 없다.  
  이벤트를 지우기, API 호출 취소, setInterval, setTimeout으로 생성된 타이머 지우기 등의 작업에 유용하다.

- **shouldComponentUpdate()**

  state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용한다.  
  `this.setState`가 호출되면 컴포넌트는 리렌더링을 일으키는데, 해당 생명주기 메서드는 컴포넌트에 영향을 받지 않는 변화에 대해 정의할 수 있다.

- **static getDerivedStateFromProps()**

  이제는 사라진 componentWillReceiveProps를 대체할 수 있는 메서드이다.  
  render()를 호출하기 직전에 호출된다.  
  static으로 선언돼 있어 this에 접근할 수 없다.  
  반환하는 객체의 내용은 모두 state로 들어가게 된다. null을 반환하면 아무 일도 일어나지 않는다.

- **getSnapShotBeforeUpdate()**

  componentsWillUpdate()를 대체할 수 있는 메서드이다.  
  DOM이 업데이트되기 직전에 호출된다.  
  반환되는 값은 componentDidUpdate로 전달된다.  
  윈도우 크기를 조절하거나 스크롤 위치를 조장하는 등의 작업을 처리하는데 유용하다.

- **getDerivedStateFromError()**

  에러 상황에서 실행되는 메서드이다.  
  자식 컴포넌트에서 에러가 발생했을 때 호출된다.

- **componentDidCatch()**

  자식 컴포넌트에서 에러가 발생했을 때 실행된다.  
  getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다.

#### 클래스 컴포넌트의 한계

- 데이터 흐름을 추적하기 어렵다.
- 애플리케이션 내부 로직의 재사용이 어렵다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.
- 코드 크기를 최적화하기 어렵다.
- 핫 리로딩을 하는데 상대적으로 불리하다.

  > **핫 리로딩 (hot reloading)**  
  > 코드에 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법

### 2.3.2 함수 컴포넌트

클래스 컴포넌트와 비교했을 때 여러모로 간결해진다.  
render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요가 없다.  
state는 객체가 아닌 각각의 원시값으로 관리되어 사용하기 편리하다.  
state는 객체도 관리할 수 있다.  
return에서 this를 사용하지 않더라도 props와 state에 접근할 수 있다.

### 2.3.2 함수 컴포넌트 vs 클래스 컴포넌트

- 생명주기 메서드의 부재

  생명주기 메서드가 함수 컴포넌트에서는 존재하지 않는다.  
  함수 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수이다. 클래스 컴포넌트는 React.Component를 상속받아 구현하는 자바스크립트 클래스이다.  
  즉, 생명주기 메서드는 React.Component에서 오는 것이기에 생명주기 메서드를 사용할 수 없다.

- 함수 컴포넌트와 렌더링된 값

  handleClick을 클릭하면 3초 뒤에 props에 있는 user를 alter로 띄워주는 기능이 존재한다. 만약 3초 사이에 props를 변경하면 어떻게 될까?  
  클래스 컴포넌트는 3초 뒤에 변경된 props를 기준으로 메세지가 뜬다.  
  함수 컴포넌트는 클릭했던 시점의 props 값을 기준으로 메세지가 뜬다

  클래스 컴포넌트는 props의 값을 항상 this로부터 가져온다.  
  render 메서드를 비롯한 리액트의 생명주기 메서드가 변경된 값을 읽을 수 있게 된다.  
  따라서, 부모 컴포넌트가 props를 변경해 컴포넌트가 다시 렌더링됐다는 것은 this.props의 값이 변경된 것이다.

  함수 컴포넌트는 props를 인수로 받는다.  
  따라서, 컴포넌트는 그 값을 변경할 수 없고 해당 값을 그대로 사용하게 된다. 이런 특성은 state도 마찬가지다.  
  함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다.  
  props와 state가 변경된다면, 다시 한 번 그 값을 기준으로 함수가 호출된다.
