## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

리액트에서 제공하는 API 중 useMemo와 useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

### 2.5.1 주장1: 필요한 곳에만 메모이제이션을 추가하자

메모이제이션은 항상 어느 정도의 트레이드 오프가 있는 기법이라고 보는 것이 옳다.  
이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유하게 된다.  
렌더링도 비용이지만 메모리에 저장하는 것도 비용이다.  
메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못한다.

또한, 리액트가 useMemo를 언제까지 성능 최적화를 위해 제공해 줄 것이라는 보장이 없다. 그렇기에 섣불리 최적화하는 것은 옳지 못하다.

일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.

### 2.5.2 주장2: 렌더링 과정의 비용은 비싸다. 모조리 메모리제이션하자

어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다.  
따라서, 우리가 memo로 지불해야 하는 비용은 props에 대한 얕은 비교뿐이다.  
물론 props가 크고 복잡해지면 이 비용 또한 커질 수 있다.  
그러나, memo를 하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다.

메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있다는 믿음을 줄 수 있다.

섣부른 초기화라 할지라도 메모이제이션을 했을 때 더 많은 이점을 누릴 수 있다.  
그리고 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.
