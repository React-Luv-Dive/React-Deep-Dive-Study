## - Flux 패턴

Flux 패턴의 등장 이전부터 존재하고 있던 MVC 패턴은 양방향 데이터 바인딩 방식이다.

하지만 브라우저가 복잡해질수록, MVC 패턴의 이러한 방식은 `상태 추적의 어려움`이라는 단점을 가져왔다.

(모델에서 뷰를 업데이트 하고, 또 뷰에서 모델을 업데이트 하는 경우)

이러한 문제점을 해결 하기 위해 `Flux` 패턴이 등장했다.

Flux 의 사전적 의미는 '흐름' 이다.

Flux 패턴은 크게 `Action`, `Dispatch`, `Model`, `View`로 구분 된다.

1. Action: 애플리케이션에서 발생하는 이벤트를 의미한다.
   어떠한 작업 (액션)을 처리할 것인지, 그리고 그 작업이 이루어질때 함께 처리할 데이터를 의미한다.

2. Dispatcher: 위의 액션을 상태값을 보관하고 있는 Store에 보내는 역할을 한다.

3. Store: 데이터의 상태를 보관하는 역할을 한다.
   Dispatcher를 통해 들어온 데이터를 통해 변화를 감지하고 이에 따라 뷰에 업데이트를 트리거한다.
   다수의 스토어가 존재할 수 있다.

4. View: 사용자에게 보이는 인터페이스로, 스토어에서 제공하는 데이터를 받아와서 렌더링하며, 사용자의 인터랙션을 통해 액션을 발생시킨다.
   리액트에서는 컴포넌트에 해당한다.

## - 예시

```tsx
type StoreState = {
  count: number;
};

type Action = { type: "add"; payload: number };

function reducer(prevState: StoreState, action: Action) {
  const { type: ActionType } = action;

  if (ActionType === "add") {
    return {
      count: prevState.count + action.payload,
    };
  }

  throw new Error(`Unexpected Action [${ActionType}]`);
}

export default function App() {
  const [state, dispatcher] = useReducer(reducer, { count: 0 });

  function handleClick() {
    dispatcher({ type: "add", payload: 1 });
  }

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={handleClick}>+</button>
    </div>
  );
}
```

액션 타입을 통해서 어플리케이션에서 발생할 이벤트와 전송할 데이터 타입을 정의한다.

`dispatcher`를 통해 스토어로 해당 데이터를 보내고, `state`가 여기서 store의 역할을 한다.

이렇듯 뷰(컴포넌트)쪽에서는 dispatcher에 변경시키고 싶은 상태값을 담아서 store에게 `action`을 전달할뿐, 직접적으로 `store`에 접근하지 않는다.

이러한 단방향 패턴을 따르는 전역상태 라이브러리들 또한 많이 생겨나게 되었다.

## - 직접 전역 상태 관리 해보기

## - store.ts

```ts
export type Initializer<T> = T extends any ? T | ((prev: T) => T) : never;

export type Store<State> = {
  get: () => State;
  set: (action: Initializer<State>) => State;
  subscribe: (callback: () => void) => void;
};

export const createStore = <State extends unknown>(
  initialState: Initializer<State>
): Store<State> => {
  // 상태의 초기화는 값을 직접 지정하거나, 상태 값을 반환하는 함수를 통해 지연 초기화를 수행할 수 있다.
  // state 변수는 스토어의 내부 상태를 보관하며, 초기값은 initialState의 타입에 따라 결정 된다.
  let state =
    typeof initialState !== "function" ? initialState : initialState();
  // 콜백 함수들을 보관할 집합(Set)을 생성한다. 이 집합은 상태 변경을 구독하는 함수들을 저장한다.
  const callbacks = new Set<() => void>();

  // 현재 상태를 반환하는 get 함수이다.
  const get = () => state;

  // 상태를 변경하는 set 함수이다.
  // nextState가 함수인 경우, 이전 상태를 기반으로 새 상태를 계산.
  const set = (nextState: State | ((prev: State) => State)) => {
    state =
      typeof nextState === "function"
        ? (nextState as (prev: State) => State)(state)
        : nextState;

    // 모든 콜백 함수를 실행하여 상태 변경을 구독 중인 함수들에게 알림
    callbacks.forEach((callback) => callback());

    return state;
  };

  // 새로운 콜백 함수를 등록하는 subscribe 함수. 이 함수는 상태 변경 시 호출될 콜백 함수를 매개변수로 받는다.
  // 함수를 등록한 후에는, 구독을 취소할 수 있는 함수를 반환한다.
  const subscribe = (callback: () => void) => {
    callbacks.add(callback);

    // 구독을 취소하는 함수를 반환. 이 함수는 해당 콜백을 콜백 집합에서 제거.
    return () => {
      callbacks.delete(callback);
    };
  };

  return { get, set, subscribe };
};
```

## - useStore.ts

```ts
import { useEffect, useState } from "react";
import { Store } from "./store";

export const useStore = <State extends unknown>(store: Store<State>) => {
  const [state, setState] = useState<State>(() => store.get());

  useEffect(() => {
    const unsubscribe = store.subscribe(() => {
      setState(store.get());
    });

    return unsubscribe;
  }, [store]);

  return [state, store.set] as const;
};
```

1. 훅의 인수로 사용할 store를 받는다.

2. 스토어의 값을 초깃값으로 하는 useState를 만든다. 이 `useState`가 컴포넌트의 렌더링을 유도한다.

3. useEffect는 store의 현재 값을 가져와 setState를 수행하는 함수를 store의 subscribe로 등록해 두었다.
   createStore내부에서 값이 변경될때마다 subscribe에 등록된 함수를 실행하므로 useStore 내부에서는 store의 값이 변경 될때마다 store의 값이 변경 되는 것을 보장받을 수 있다.

4. 마지막으로 useEffect의 클린업 함수로 unsubscribe를 등록해둔다. useEffect의 작동이 끝난 이후에는 callback에서 해당 함수를 제거해서 callback이 계속해서 쌓이는 현상을 방지한다.

## - 살펴보기

```ts
const store = createStore({ count: 0 });

console.log("store : ", store);
```

![](https://dp71rnme1p14w.cloudfront.net/compressed_1715122548300--2024-05-08-7.55.45.png)

## - GlobalState.tsx

```tsx
export default function GlobalState() {
  const [state, setState] = useStore(store);

  console.log("컴포넌트 내부 state : ", state);

  const handleClick = () => {
    setState((prev) => ({
      count: prev.count + 1,
    }));
  };

  return (
    <div>
      <h1>Count1 : {state.count}</h1>
      <button onClick={handleClick}>+</button>
    </div>
  );
}
```

![](https://dp71rnme1p14w.cloudfront.net/compressed_1715123623068--2024-05-08-8.13.40.png)

하지만 현재 상태 관리에서 문제점은, 만약 객체에서 일부값이 변경되더라도 무조건 리렌더링이 일어난다는 것이다.

만약

```ts
const store = createStore({ count: 0, name: "brgndy" });
```

여기서 count 값이 변했을때만 리렌더링이 일어나야하는데, name 값이 변하더라도 리렌더링이 발생하는 문제점이 발생한다. (모든 subscriber들에게 알람을 보내서 리렌더링이 발생함.)

```ts
import { useEffect, useState } from "react";
import { Store } from "./store";

const useStoreSelector = <State extends unknown, Value extends unknown>(
  store: Store<State>,
  selector: (state: State) => Value
) => {
  const [state, setState] = useState(() => selector(store.get()));

  useEffect(() => {
    const unsubscribe = store.subscribe(() => {
      const value = selector(store.get());

      setState(value);
    });

    return unsubscribe;
  }, [store, selector]);

  return state;
};

export default useStoreSelector;
```

```tsx
const store = createStore({ count: 0, text: "hi" });

function Counter() {
  const counter = useStoreSelector(
    store,
    useCallback((state) => state.count, [])
  );

  function handleClick() {
    store.set((prev) => ({ ...prev, count: prev.count + 1 }));
  }

  useEffect(() => {
    console.log("counter rendered");
  }, []);

  return (
    <>
      <h3>{counter}</h3>
      <button onClick={handleClick}>+</button>
    </>
  );
}

export default Counter;
```

위 처럼 `useStoreSelector`를 사용하여 필요한 값이 업데이트 되었을때만 수행하도록 할수 있다.

이때 주의할점은 컴포넌트 외부에 selector를 설정해주거나 useCallback으로 감싸주어야한다는 것이다.

안그러면 컴포넌트가 리렌더링 될때마다 `useStoreSelector`내부에 `subscribe`가 매번 실행 된다.
