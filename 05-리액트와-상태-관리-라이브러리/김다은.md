## 5.1 상태 관리는 왜 필요한가?

### 상태란?

- 의미를 지닌 값
- 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값

### 전역 상태

애플리케이션 전체적으로 관리하는 상태가 있다면, 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상도 방지해야 한다.(tearing)

<br/>

### Flux 패턴

페이스북 팀은 웹 애플리케이션의 상태를 추적하기 어려워진 원인으로 **양방향 데이터 바인딩**으로 봤다. 뷰가 모델(자바스크립트)을 변경할 수 있고, 그 반대도 가능하기 때문에 관리하기 어렵다고 본 것이다. 따라서 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 Flux 패턴을 제안했다.

![[Pasted image 20240510140628.png]]

#### 용어

- action
  어떤 작업을 처리할 액션과 변경될 데이터를 묶은 객체다.
- dispatcher
  콜백 함수 형태로서 액션을 스토어에 보내는 역할을 한다.
- store
  실제로 상태를 변경할 수 있는 메서드를 가진 객체다. 액션의 타입에 따라 어떻게 이를 변경할지 정의한다.
- view
  리액트의 컴포넌트에 해당하는 부분이다. 뷰에서 액션을 호출한다.

<br/>

#### 단방향 데이터 바인딩의 장단점

- 단점
  사용자의 입력에 따라(뷰, 액션) 데이터를 갱신하고, 업데이트의 방식까지 코드로 작성해야 하므로 코드의 양이 많아진다.
- 장점
  데이터의 흐름이 액션이라는 한 방향으로 제한되기 때문에 데이터의 흐름을 추적하기 쉽다.

<br/>

### Redux의 등장

redux는 flux 패턴에 Elm 아키텍처를 적용했다.

리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트 하는 작업을 디스패치한다.
이러한 작업은 Reducer 함수로 발생시킬 수 있는데, 이 함수는 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만든 상태를 전파한다.

- 리덕스는 하나의 글로벌 상태 객체를 통해 props drilling 문제를 해결할 수 있었다.
- 스토어가 필요한 컴포넌트는 connect만 쓰면 스토어에 바로 접근할 수도 있었다.

<br/>

### Context API와 useContext

- props drilling 문제를 해결하기 위한 도구로써 나왔다. 즉, **Context API는 상태 관리가 아닌 주입을 도와주는 기능**이다.
- 상위 컴포넌트가 렌더링되면 getChildContext가 호출됨과 동시에 모든 자식 요소가 렌더링된다는 문제도 있다.

<br/>

---

## 보충 공부

### Web tearing(찢어짐 현상)이란 무엇인가?

> 웹 페이지가 비동기적인 데이터 업데이트로 인해 일관성 없이 렌더링되는 현상
> React와 같은 선언적 UI 라이브러리에서 **상태 업데이트가 화면에 반영되기 전에 중간 상태가 사용자에게 노출되는** 것을 말한다.

하나의 페이지에서 여러 API 요청 결과를 동시에 렌더링해야 할 때, 각 요청의 응답 시간이 달라 일관성 없는 UI 상태가 잠깐 동안 보일 수 있다.

예를 들어 대시보드 애플리케이션에서 일부 위젯이 다른 위젯보다 빨리 업데이트되어 새로운 정보와 이전 정보를 혼재해서 보여주는 경우가 있을 수 있다.

Web tearing은 개발자가 컴포넌트 간의 상태 불일치를 적절히 관리하지 못했을 때 발상하는 문제다. 따라서 애플리케이션의 상태 관리 전략이나 컴포넌트 간의 데이터 흐름 설계 문제로 볼 수 있다.

상태 관리 라이브러리 자체는 이런 web tearing 문제를 해결해주지 않는다. 대신 Redux Thunk, React Query와 같은 비동기 작업(데이터 패칭)과 관련한 상태를 관리하는 라이브러리를 적절하게 사용하면 tearing을 방지할 수 있다.

<br/>

### Redux Thunk

Redux 자체는 동기적인 상태 업데이트만 지원하므로, 자체적으로는 tearing 문제를 해결하지 않는다. Redux Thunk는 비동기 작업을 동기적인 흐름으로 관리할 수 있어 tearing 현상을 간접적으로 줄일 수 있다.

1. **동기적 상태 업데이트**: API 호출 결과를 받은 후에 상태 업데이트를 트리거하도록 제한할 수 있다. 액션을 디스패치하는 시점을 정확히 제어할 수 있게 하고, 상태 업데이트가 모든 관련 컴포넌트에 동시에 반영될 수 있도록 한다.
2. **일관된 상태 변경**: 비동기 작업 후 상태 변경을 한 번에 수행함으로써 여러 컴포넌트에서 동일한 상태를 참조하게 된다.

```js
// action types
const FETCH_USER_REQUEST = 'FETCH_USER_REQUEST';
const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';

// action creators
const fetchUserRequest = () => {
  return {
    type: FETCH_USER_REQUEST,
  };
};

const fetchUserSuccess = (user) => {
  return {
    type: FETCH_USER_SUCCESS,
    payload: user,
  };
};

const fetchUserFailure = (error) => {
  return {
    type: FETCH_USER_FAILURE,
    payload: error,
  };
};

// thunk action
const fetchUserData = (userId) => {
  return (dispatch) => {
    dispatch(fetchUserRequest());
    fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
      .then((response) => response.json())
      .then((data) => {
        dispatch(fetchUserSuccess(data)); // dispatch user data on success
      })
      .catch((error) => {
        dispatch(fetchUserFailure(error.message)); // dispatch error message on failure
      });
  };
};

const initialState = {
  loading: false,
  user: {},
  error: '',
};

const userReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_USER_REQUEST:
      return {
        ...state,
        loading: true,
      };
    case FETCH_USER_SUCCESS:
      return {
        loading: false,
        user: action.payload,
        error: '',
      };
    case FETCH_USER_FAILURE:
      return {
        loading: false,
        user: {},
        error: action.payload,
      };
    default:
      return state;
  }
};

// 사용 예
import { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';

function UserProfile({ userId }) {
  const dispatch = useDispatch();
  const user = useSelector((state) => state.user);
  const loading = useSelector((state) => state.loading);
  const error = useSelector((state) => state.error);

  useEffect(() => {
    dispatch(fetchUserData(userId));
  }, [dispatch, userId]);

  return (
    <div>
      {loading && <p>Loading...</p>}
      {error && <p>Error: {error}</p>}
      {user && (
        <div>
          <h1>{user.name}</h1>
          <p>{user.email}</p>
        </div>
      )}
    </div>
  );
}
```

<br/>

### React Query

React Query는 서버 상태를 관리하는 데 최적화되어 있는 라이브러리다.

1. **백그라운드 업데이트와 캐싱**: 기본적으로 캐시된 데이터를 사용하여 UI가 일관된 상태를 보여줄 수 있다. 또한 이 캐시 데이터는 백그라운드에서 자동으로 업데이트되어 사용자는 데이터가 최신인지에 대한 걱정 없이 캐시된 데이터를 볼 수 있다.
2. **상태의 일관성 보장**: 쿼리 상태와 뮤테이션 상태를 관리하기 때문에 관련 컴포넌트에 동일한 데이터를 제공한다. 이로써 상태 변경에 따른 불일치를 줄일 수 있다.

위와 같은 기능 제공으로 개발자가 직접 상태를 관리하는 복잡성을 줄여 tearing 발생 가능성을 낮춘다.
