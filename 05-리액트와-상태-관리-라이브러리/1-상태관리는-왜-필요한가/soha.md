## 5.1 상태관리는 왜 필요한가?

#### 상태?

어떠한 의미를 지닌 값으로 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다. 즉, 웹 애플리케이션에서 상태란 상호 작용이 가능한 모든 요소의 현재 값을 의미한다.

**ex)**

- UI: 다크/라이트 모드, input, 알림창 노출 여부 등의 상태가 존재한다.

- URL: 브라우저에서 관리되고 있는 상태값이다. URL 주소에 studentId=122 등이 있다면 URL에 상태가 존재하는 것으로 해당 상태는 사용자의 라우팅에 따라 변경된다.

- form: 로딩 중(loading), 제출 상태(submit), 접근 불가능(disabled), 유효한 값(validation) 등 모두가 상태로 관리된다.

- 서버에서 가져온 값: 클라이언트에서 서버로 요청을 통해 가져온 값도 상태이다. 대표적으로 API 요청이 있다.

> **tearing**
> 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션에 찢어지는 현상.
> 하나의 상태에 따라 서로 다른 결과물을 사용자에게 보여준다.

### 5.1.1 리액트 상태 관리의 역사

#### Flux 패턴

기존의 양방향 데이터 바인딩이 아닌 단방향으로 데이터 흐름을 변경할 수 있도록 한다.

![flux pattern](https://github.com/woowacourse/react-modules/assets/77609591/d038c7da-71a6-4189-bcb4-fa4e615407d6)

**용어**

- 액션(action): 어떠한 작업을 처리할 액션과 그 액션 발생 시 함게 포함시킬 데이터. 액션 타입과 데이터를 각각 정의해 디스패치로 보낸다.

- 디스패치(dispatcher): 액션을 스토어로 보내는 역할. 콜백 함수 형태로 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.

- 스토어(store): 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드가 존재. 액션 타입에 따라 어떻게 변경할지 정의돼 있다.

- 뷰(view): 리액트 컴포넌트에 해당하는 부분으로 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할. 뷰에서 사용자의 입력이나 행위에 따라 상태를 업데이트 할 수 있다. 이 경우에는 그림처럼 뷰에서 액션을 호출하는 구조로 구성된다.

**장단점**

- 장점

  데이터의 흐름이 모두 액션이라는 단방향으로 줄어들어 데이터의 흐름을 추적하기 쉽다.
  또한 코드를 이해하기 수월하다.

- 단점

  사용자 입력에 따라 데이터를 갱신 및 화면 업데이트 등을 코드로 작성하여 코드의 양이 많아진다. 따라서 개발자가 수고스러워진다.

리액트는 단방향 데이터 바인딩을 기반으로 한 라이브러리이기에 Flux 패턴과 궁합이 좋다.

#### Redux

Flux 패턴을 구현하기 위해 만들어진 라이브러리 중 하나였다. 여기에 Elm 아키텍처를 도입했다.  
하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수정한다. reducer 함수로 이런 작업을 발생시켰으며, 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 새롭게 만들어진 상태를 전파한다.

하나의 글로벌 상태 객체를 통해 하위 컴포넌트에 상태를 전파할 수 있기 떄문에 props를 깊이 전파해야 하는 prop 내려주기 문제를 해결할 수 있었다. 또한, 스토어가 필요한 컴포넌트라면 connect를 사용하여 스토어에 바로 접근할 수 있었다.

그러나 리덕스는 하나의 상태를 바꾸기 위해 필요한 보일러플레이트가 너무 많다는 문제가 존재했다.

> **보일러플레이트**  
>  최소한의 변경으로 여러곳에서 재사용되며, 반복적으로 비슷한 형태를 띄는 코드

**Elm?**  
웹 페이지를 선언적으로 작성하기 위한 언어이다. Flux와 마찬가지로 데이터 흐름을 세가지로 분류해 단방향으로 강제했다.  
model, update, view가 Elm 아키텍처의 핵심이다.

- model: 애플리케이션의 상태를 의미. 초기값 0

- view: model을 표현하는 HTML. model을 인수로 받아 HTML을 표현

- update: model을 수정하는 방식. Increment, Decrement를 선언해 각 방식이 어떻게 모델을 수정하는지 나타냄.

#### Context API 와 useContext

props로 상태를 넘겨주지 않더라도 Context API를 사용하여 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있다.

그러나 Context API는 상태 관리가 아닌 주입을 도와주는 기능이기에 렌더링을 막아주는 기능이 존재하지 않아 사용할 때 주의가 필요하다.

#### Hook, React Query와 SWR

훅을 통해 state를 손쉽게 재사용이 가능할 수 있게 되었다. 이로 인해 React Query와 SWR이 등장하였다.

두 라이브러리 모두 외부에서 데이터를 불러오는 fetch에 특화된 라이브러리이다. 그러나 API 호출에 대한 상태를 관리하고 있기에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

#### Recoil, Zustand, Jotai, Valtio

요즘 새롭게 떠오르고 있는 상태 관리 라이브러리로 리덕스와의 차이점은 훅을 활용해 작은 크기의 상태를 효율적을 관리한다는 것이다.

기존 상태 관리 라이브러리의 아쉬워던 점인 전역 상태 관리 패러다임에서 벗어나 개발자가 원하는 만큼만 상태를 지역적으로 관리할 수 있도록 한다. 또한, 훅을 지원함올 함수 컴포넌트에서 손쉽게 사용할 수 있다.
